package iamexampledb

// Code generated by spanner-aip-go. DO NOT EDIT.

import (
	"context"
	"fmt"
	"time"

	"cloud.google.com/go/spanner"
	"cloud.google.com/go/spanner/spansql"
	"google.golang.org/api/iterator"
)

type IamPolicyBindingsRow struct {
	Resource     string `spanner:"resource"`
	BindingIndex int64  `spanner:"binding_index"`
	Role         string `spanner:"role"`
	MemberIndex  int64  `spanner:"member_index"`
	Member       string `spanner:"member"`
}

func (*IamPolicyBindingsRow) ColumnNames() []string {
	return []string{
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	}
}

func (*IamPolicyBindingsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	}
}

func (*IamPolicyBindingsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("resource"),
		spansql.ID("binding_index"),
		spansql.ID("role"),
		spansql.ID("member_index"),
		spansql.ID("member"),
	}
}

func (r *IamPolicyBindingsRow) Validate() error {
	return nil
}

func (r *IamPolicyBindingsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "resource":
			if err := row.Column(i, &r.Resource); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: resource column: %w", err)
			}
		case "binding_index":
			if err := row.Column(i, &r.BindingIndex); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: binding_index column: %w", err)
			}
		case "role":
			if err := row.Column(i, &r.Role); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: role column: %w", err)
			}
		case "member_index":
			if err := row.Column(i, &r.MemberIndex); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: member_index column: %w", err)
			}
		case "member":
			if err := row.Column(i, &r.Member); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: member column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal iam_policy_bindings row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *IamPolicyBindingsRow) Mutate() (string, []string, []interface{}) {
	return "iam_policy_bindings", r.ColumnNames(), []interface{}{
		r.Resource,
		r.BindingIndex,
		r.Role,
		r.MemberIndex,
		r.Member,
	}
}

func (r *IamPolicyBindingsRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "resource":
			values = append(values, r.Resource)
		case "binding_index":
			values = append(values, r.BindingIndex)
		case "role":
			values = append(values, r.Role)
		case "member_index":
			values = append(values, r.MemberIndex)
		case "member":
			values = append(values, r.Member)
		default:
			panic(fmt.Errorf("table iam_policy_bindings does not have column %s", column))
		}
	}
	return "iam_policy_bindings", columns, values
}

func (r *IamPolicyBindingsRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	)
	return r.MutateColumns(columns)
}

func (r *IamPolicyBindingsRow) Key() IamPolicyBindingsKey {
	return IamPolicyBindingsKey{
		Resource:     r.Resource,
		BindingIndex: r.BindingIndex,
		Role:         r.Role,
		MemberIndex:  r.MemberIndex,
		Member:       r.Member,
	}
}

type ShippersRow struct {
	ShipperId   string           `spanner:"shipper_id"`
	CreateTime  time.Time        `spanner:"create_time"`
	UpdateTime  time.Time        `spanner:"update_time"`
	DeleteTime  spanner.NullTime `spanner:"delete_time"`
	DisplayName string           `spanner:"display_name"`
}

func (*ShippersRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
	}
}

func (*ShippersRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
	}
}

func (*ShippersRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
		spansql.ID("display_name"),
	}
}

func (r *ShippersRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.DisplayName) > 63 {
		return fmt.Errorf("column display_name length > 63")
	}
	return nil
}

func (r *ShippersRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal shippers row: shipper_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal shippers row: delete_time column: %w", err)
			}
		case "display_name":
			if err := row.Column(i, &r.DisplayName); err != nil {
				return fmt.Errorf("unmarshal shippers row: display_name column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal shippers row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *ShippersRow) Mutate() (string, []string, []interface{}) {
	return "shippers", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
		r.DisplayName,
	}
}

func (r *ShippersRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		case "display_name":
			values = append(values, r.DisplayName)
		default:
			panic(fmt.Errorf("table shippers does not have column %s", column))
		}
	}
	return "shippers", columns, values
}

func (r *ShippersRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"shipper_id",
		"create_time",
		"update_time",
		"display_name",
	)
	if !r.DeleteTime.IsNull() {
		columns = append(columns, "delete_time")
	}
	return r.MutateColumns(columns)
}

func (r *ShippersRow) Key() ShippersKey {
	return ShippersKey{
		ShipperId: r.ShipperId,
	}
}

type SitesRow struct {
	ShipperId   string              `spanner:"shipper_id"`
	SiteId      string              `spanner:"site_id"`
	CreateTime  time.Time           `spanner:"create_time"`
	UpdateTime  time.Time           `spanner:"update_time"`
	DeleteTime  spanner.NullTime    `spanner:"delete_time"`
	DisplayName string              `spanner:"display_name"`
	Latitude    spanner.NullFloat64 `spanner:"latitude"`
	Longitude   spanner.NullFloat64 `spanner:"longitude"`
}

func (*SitesRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"site_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
		"latitude",
		"longitude",
	}
}

func (*SitesRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"site_id",
		"create_time",
		"update_time",
		"delete_time",
		"display_name",
		"latitude",
		"longitude",
	}
}

func (*SitesRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("site_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
		spansql.ID("display_name"),
		spansql.ID("latitude"),
		spansql.ID("longitude"),
	}
}

func (r *SitesRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.SiteId) > 63 {
		return fmt.Errorf("column site_id length > 63")
	}
	if len(r.DisplayName) > 63 {
		return fmt.Errorf("column display_name length > 63")
	}
	return nil
}

func (r *SitesRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal sites row: shipper_id column: %w", err)
			}
		case "site_id":
			if err := row.Column(i, &r.SiteId); err != nil {
				return fmt.Errorf("unmarshal sites row: site_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal sites row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal sites row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal sites row: delete_time column: %w", err)
			}
		case "display_name":
			if err := row.Column(i, &r.DisplayName); err != nil {
				return fmt.Errorf("unmarshal sites row: display_name column: %w", err)
			}
		case "latitude":
			if err := row.Column(i, &r.Latitude); err != nil {
				return fmt.Errorf("unmarshal sites row: latitude column: %w", err)
			}
		case "longitude":
			if err := row.Column(i, &r.Longitude); err != nil {
				return fmt.Errorf("unmarshal sites row: longitude column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal sites row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *SitesRow) Mutate() (string, []string, []interface{}) {
	return "sites", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.SiteId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
		r.DisplayName,
		r.Latitude,
		r.Longitude,
	}
}

func (r *SitesRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "site_id":
			values = append(values, r.SiteId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		case "display_name":
			values = append(values, r.DisplayName)
		case "latitude":
			values = append(values, r.Latitude)
		case "longitude":
			values = append(values, r.Longitude)
		default:
			panic(fmt.Errorf("table sites does not have column %s", column))
		}
	}
	return "sites", columns, values
}

func (r *SitesRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"shipper_id",
		"site_id",
		"create_time",
		"update_time",
		"display_name",
	)
	if !r.DeleteTime.IsNull() {
		columns = append(columns, "delete_time")
	}
	if !r.Latitude.IsNull() {
		columns = append(columns, "latitude")
	}
	if !r.Longitude.IsNull() {
		columns = append(columns, "longitude")
	}
	return r.MutateColumns(columns)
}

func (r *SitesRow) Key() SitesKey {
	return SitesKey{
		ShipperId: r.ShipperId,
		SiteId:    r.SiteId,
	}
}

type ShipmentsRow struct {
	ShipperId            string               `spanner:"shipper_id"`
	ShipmentId           string               `spanner:"shipment_id"`
	CreateTime           time.Time            `spanner:"create_time"`
	UpdateTime           time.Time            `spanner:"update_time"`
	DeleteTime           spanner.NullTime     `spanner:"delete_time"`
	OriginSiteId         string               `spanner:"origin_site_id"`
	DestinationSiteId    string               `spanner:"destination_site_id"`
	PickupEarliestTime   time.Time            `spanner:"pickup_earliest_time"`
	PickupLatestTime     time.Time            `spanner:"pickup_latest_time"`
	DeliveryEarliestTime time.Time            `spanner:"delivery_earliest_time"`
	DeliveryLatestTime   time.Time            `spanner:"delivery_latest_time"`
	Annotations          []spanner.NullString `spanner:"annotations"`
	LineItems            []*LineItemsRow      `spanner:"line_items"`
}

func (*ShipmentsRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"shipment_id",
		"create_time",
		"update_time",
		"delete_time",
		"origin_site_id",
		"destination_site_id",
		"pickup_earliest_time",
		"pickup_latest_time",
		"delivery_earliest_time",
		"delivery_latest_time",
		"annotations",
	}
}

func (*ShipmentsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"shipment_id",
		"create_time",
		"update_time",
		"delete_time",
		"origin_site_id",
		"destination_site_id",
		"pickup_earliest_time",
		"pickup_latest_time",
		"delivery_earliest_time",
		"delivery_latest_time",
		"annotations",
	}
}

func (*ShipmentsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("shipment_id"),
		spansql.ID("create_time"),
		spansql.ID("update_time"),
		spansql.ID("delete_time"),
		spansql.ID("origin_site_id"),
		spansql.ID("destination_site_id"),
		spansql.ID("pickup_earliest_time"),
		spansql.ID("pickup_latest_time"),
		spansql.ID("delivery_earliest_time"),
		spansql.ID("delivery_latest_time"),
		spansql.ID("annotations"),
	}
}

func (r *ShipmentsRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.ShipmentId) > 63 {
		return fmt.Errorf("column shipment_id length > 63")
	}
	if len(r.OriginSiteId) > 63 {
		return fmt.Errorf("column origin_site_id length > 63")
	}
	if len(r.DestinationSiteId) > 63 {
		return fmt.Errorf("column destination_site_id length > 63")
	}
	if r.Annotations == nil {
		return fmt.Errorf("array column annotations is nil")
	}
	return nil
}

func (r *ShipmentsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipper_id column: %w", err)
			}
		case "shipment_id":
			if err := row.Column(i, &r.ShipmentId); err != nil {
				return fmt.Errorf("unmarshal shipments row: shipment_id column: %w", err)
			}
		case "create_time":
			if err := row.Column(i, &r.CreateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: create_time column: %w", err)
			}
		case "update_time":
			if err := row.Column(i, &r.UpdateTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: update_time column: %w", err)
			}
		case "delete_time":
			if err := row.Column(i, &r.DeleteTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delete_time column: %w", err)
			}
		case "origin_site_id":
			if err := row.Column(i, &r.OriginSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: origin_site_id column: %w", err)
			}
		case "destination_site_id":
			if err := row.Column(i, &r.DestinationSiteId); err != nil {
				return fmt.Errorf("unmarshal shipments row: destination_site_id column: %w", err)
			}
		case "pickup_earliest_time":
			if err := row.Column(i, &r.PickupEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_earliest_time column: %w", err)
			}
		case "pickup_latest_time":
			if err := row.Column(i, &r.PickupLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: pickup_latest_time column: %w", err)
			}
		case "delivery_earliest_time":
			if err := row.Column(i, &r.DeliveryEarliestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_earliest_time column: %w", err)
			}
		case "delivery_latest_time":
			if err := row.Column(i, &r.DeliveryLatestTime); err != nil {
				return fmt.Errorf("unmarshal shipments row: delivery_latest_time column: %w", err)
			}
		case "annotations":
			if err := row.Column(i, &r.Annotations); err != nil {
				return fmt.Errorf("unmarshal shipments row: annotations column: %w", err)
			}
		case "line_items":
			if err := row.Column(i, &r.LineItems); err != nil {
				return fmt.Errorf("unmarshal shipments interleaved row: line_items column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal shipments row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *ShipmentsRow) Mutate() (string, []string, []interface{}) {
	return "shipments", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.ShipmentId,
		r.CreateTime,
		r.UpdateTime,
		r.DeleteTime,
		r.OriginSiteId,
		r.DestinationSiteId,
		r.PickupEarliestTime,
		r.PickupLatestTime,
		r.DeliveryEarliestTime,
		r.DeliveryLatestTime,
		r.Annotations,
	}
}

func (r *ShipmentsRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "shipment_id":
			values = append(values, r.ShipmentId)
		case "create_time":
			values = append(values, r.CreateTime)
		case "update_time":
			values = append(values, r.UpdateTime)
		case "delete_time":
			values = append(values, r.DeleteTime)
		case "origin_site_id":
			values = append(values, r.OriginSiteId)
		case "destination_site_id":
			values = append(values, r.DestinationSiteId)
		case "pickup_earliest_time":
			values = append(values, r.PickupEarliestTime)
		case "pickup_latest_time":
			values = append(values, r.PickupLatestTime)
		case "delivery_earliest_time":
			values = append(values, r.DeliveryEarliestTime)
		case "delivery_latest_time":
			values = append(values, r.DeliveryLatestTime)
		case "annotations":
			values = append(values, r.Annotations)
		default:
			panic(fmt.Errorf("table shipments does not have column %s", column))
		}
	}
	return "shipments", columns, values
}

func (r *ShipmentsRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"shipper_id",
		"shipment_id",
		"create_time",
		"update_time",
		"origin_site_id",
		"destination_site_id",
		"pickup_earliest_time",
		"pickup_latest_time",
		"delivery_earliest_time",
		"delivery_latest_time",
		"annotations",
	)
	if !r.DeleteTime.IsNull() {
		columns = append(columns, "delete_time")
	}
	return r.MutateColumns(columns)
}

func (r *ShipmentsRow) Key() ShipmentsKey {
	return ShipmentsKey{
		ShipperId:  r.ShipperId,
		ShipmentId: r.ShipmentId,
	}
}

type LineItemsRow struct {
	ShipperId  string  `spanner:"shipper_id"`
	ShipmentId string  `spanner:"shipment_id"`
	LineNumber int64   `spanner:"line_number"`
	Title      string  `spanner:"title"`
	Quantity   float64 `spanner:"quantity"`
	WeightKg   float64 `spanner:"weight_kg"`
	VolumeM3   float64 `spanner:"volume_m3"`
}

func (*LineItemsRow) ColumnNames() []string {
	return []string{
		"shipper_id",
		"shipment_id",
		"line_number",
		"title",
		"quantity",
		"weight_kg",
		"volume_m3",
	}
}

func (*LineItemsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"shipper_id",
		"shipment_id",
		"line_number",
		"title",
		"quantity",
		"weight_kg",
		"volume_m3",
	}
}

func (*LineItemsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("shipper_id"),
		spansql.ID("shipment_id"),
		spansql.ID("line_number"),
		spansql.ID("title"),
		spansql.ID("quantity"),
		spansql.ID("weight_kg"),
		spansql.ID("volume_m3"),
	}
}

func (r *LineItemsRow) Validate() error {
	if len(r.ShipperId) > 63 {
		return fmt.Errorf("column shipper_id length > 63")
	}
	if len(r.ShipmentId) > 63 {
		return fmt.Errorf("column shipment_id length > 63")
	}
	if len(r.Title) > 63 {
		return fmt.Errorf("column title length > 63")
	}
	return nil
}

func (r *LineItemsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "shipper_id":
			if err := row.Column(i, &r.ShipperId); err != nil {
				return fmt.Errorf("unmarshal line_items row: shipper_id column: %w", err)
			}
		case "shipment_id":
			if err := row.Column(i, &r.ShipmentId); err != nil {
				return fmt.Errorf("unmarshal line_items row: shipment_id column: %w", err)
			}
		case "line_number":
			if err := row.Column(i, &r.LineNumber); err != nil {
				return fmt.Errorf("unmarshal line_items row: line_number column: %w", err)
			}
		case "title":
			if err := row.Column(i, &r.Title); err != nil {
				return fmt.Errorf("unmarshal line_items row: title column: %w", err)
			}
		case "quantity":
			if err := row.Column(i, &r.Quantity); err != nil {
				return fmt.Errorf("unmarshal line_items row: quantity column: %w", err)
			}
		case "weight_kg":
			if err := row.Column(i, &r.WeightKg); err != nil {
				return fmt.Errorf("unmarshal line_items row: weight_kg column: %w", err)
			}
		case "volume_m3":
			if err := row.Column(i, &r.VolumeM3); err != nil {
				return fmt.Errorf("unmarshal line_items row: volume_m3 column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal line_items row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *LineItemsRow) Mutate() (string, []string, []interface{}) {
	return "line_items", r.ColumnNames(), []interface{}{
		r.ShipperId,
		r.ShipmentId,
		r.LineNumber,
		r.Title,
		r.Quantity,
		r.WeightKg,
		r.VolumeM3,
	}
}

func (r *LineItemsRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "shipper_id":
			values = append(values, r.ShipperId)
		case "shipment_id":
			values = append(values, r.ShipmentId)
		case "line_number":
			values = append(values, r.LineNumber)
		case "title":
			values = append(values, r.Title)
		case "quantity":
			values = append(values, r.Quantity)
		case "weight_kg":
			values = append(values, r.WeightKg)
		case "volume_m3":
			values = append(values, r.VolumeM3)
		default:
			panic(fmt.Errorf("table line_items does not have column %s", column))
		}
	}
	return "line_items", columns, values
}

func (r *LineItemsRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"shipper_id",
		"shipment_id",
		"line_number",
		"title",
		"quantity",
		"weight_kg",
		"volume_m3",
	)
	return r.MutateColumns(columns)
}

func (r *LineItemsRow) Key() LineItemsKey {
	return LineItemsKey{
		ShipperId:  r.ShipperId,
		ShipmentId: r.ShipmentId,
		LineNumber: r.LineNumber,
	}
}

type IamPolicyBindingsKey struct {
	Resource     string
	BindingIndex int64
	Role         string
	MemberIndex  int64
	Member       string
}

func (k IamPolicyBindingsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.Resource,
		k.BindingIndex,
		k.Role,
		k.MemberIndex,
		k.Member,
	}
}

func (k IamPolicyBindingsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k IamPolicyBindingsKey) Delete() *spanner.Mutation {
	return spanner.Delete("iam_policy_bindings", k.SpannerKey())
}

func (IamPolicyBindingsKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("resource"), Desc: false},
		{Expr: spansql.ID("binding_index"), Desc: false},
		{Expr: spansql.ID("role"), Desc: false},
		{Expr: spansql.ID("member_index"), Desc: false},
		{Expr: spansql.ID("member"), Desc: false},
	}
}

func (k IamPolicyBindingsKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("resource"),
		RHS: spansql.StringLiteral(k.Resource),
	})
	cmp1 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("binding_index"),
		RHS: spansql.IntegerLiteral(k.BindingIndex),
	})
	cmp2 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("role"),
		RHS: spansql.StringLiteral(k.Role),
	})
	cmp3 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("member_index"),
		RHS: spansql.IntegerLiteral(k.MemberIndex),
	})
	cmp4 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("member"),
		RHS: spansql.StringLiteral(k.Member),
	})
	b := cmp0
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp1,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp2,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp3,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp4,
	}
	return spansql.Paren{Expr: b}
}

type ShippersKey struct {
	ShipperId string
}

func (k ShippersKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
	}
}

func (k ShippersKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k ShippersKey) Delete() *spanner.Mutation {
	return spanner.Delete("shippers", k.SpannerKey())
}

func (ShippersKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("shipper_id"), Desc: false},
	}
}

func (k ShippersKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	b := cmp0
	return spansql.Paren{Expr: b}
}

type SitesKey struct {
	ShipperId string
	SiteId    string
}

func (k SitesKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.SiteId,
	}
}

func (k SitesKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k SitesKey) Delete() *spanner.Mutation {
	return spanner.Delete("sites", k.SpannerKey())
}

func (SitesKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("shipper_id"), Desc: false},
		{Expr: spansql.ID("site_id"), Desc: false},
	}
}

func (k SitesKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	cmp1 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("site_id"),
		RHS: spansql.StringLiteral(k.SiteId),
	})
	b := cmp0
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp1,
	}
	return spansql.Paren{Expr: b}
}

type ShipmentsKey struct {
	ShipperId  string
	ShipmentId string
}

func (k ShipmentsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.ShipmentId,
	}
}

func (k ShipmentsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k ShipmentsKey) Delete() *spanner.Mutation {
	return spanner.Delete("shipments", k.SpannerKey())
}

func (ShipmentsKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("shipper_id"), Desc: false},
		{Expr: spansql.ID("shipment_id"), Desc: false},
	}
}

func (k ShipmentsKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	cmp1 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipment_id"),
		RHS: spansql.StringLiteral(k.ShipmentId),
	})
	b := cmp0
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp1,
	}
	return spansql.Paren{Expr: b}
}

type LineItemsKey struct {
	ShipperId  string
	ShipmentId string
	LineNumber int64
}

func (k LineItemsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.ShipperId,
		k.ShipmentId,
		k.LineNumber,
	}
}

func (k LineItemsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k LineItemsKey) Delete() *spanner.Mutation {
	return spanner.Delete("line_items", k.SpannerKey())
}

func (LineItemsKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("shipper_id"), Desc: false},
		{Expr: spansql.ID("shipment_id"), Desc: false},
		{Expr: spansql.ID("line_number"), Desc: false},
	}
}

func (k LineItemsKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipper_id"),
		RHS: spansql.StringLiteral(k.ShipperId),
	})
	cmp1 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("shipment_id"),
		RHS: spansql.StringLiteral(k.ShipmentId),
	})
	cmp2 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("line_number"),
		RHS: spansql.IntegerLiteral(k.LineNumber),
	})
	b := cmp0
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp1,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp2,
	}
	return spansql.Paren{Expr: b}
}

type IamPolicyBindingsRowIterator interface {
	Next() (*IamPolicyBindingsRow, error)
	Do(f func(row *IamPolicyBindingsRow) error) error
	Stop()
}

type streamingIamPolicyBindingsRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingIamPolicyBindingsRowIterator) Next() (*IamPolicyBindingsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row IamPolicyBindingsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingIamPolicyBindingsRowIterator) Do(f func(row *IamPolicyBindingsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row IamPolicyBindingsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedIamPolicyBindingsRowIterator struct {
	rows []*IamPolicyBindingsRow
	err  error
}

func (i *bufferedIamPolicyBindingsRowIterator) Next() (*IamPolicyBindingsRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedIamPolicyBindingsRowIterator) Do(f func(row *IamPolicyBindingsRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedIamPolicyBindingsRowIterator) Stop() {}

type ShippersRowIterator interface {
	Next() (*ShippersRow, error)
	Do(f func(row *ShippersRow) error) error
	Stop()
}

type streamingShippersRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingShippersRowIterator) Next() (*ShippersRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row ShippersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingShippersRowIterator) Do(f func(row *ShippersRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row ShippersRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedShippersRowIterator struct {
	rows []*ShippersRow
	err  error
}

func (i *bufferedShippersRowIterator) Next() (*ShippersRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedShippersRowIterator) Do(f func(row *ShippersRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedShippersRowIterator) Stop() {}

type SitesRowIterator interface {
	Next() (*SitesRow, error)
	Do(f func(row *SitesRow) error) error
	Stop()
}

type streamingSitesRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingSitesRowIterator) Next() (*SitesRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row SitesRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingSitesRowIterator) Do(f func(row *SitesRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row SitesRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedSitesRowIterator struct {
	rows []*SitesRow
	err  error
}

func (i *bufferedSitesRowIterator) Next() (*SitesRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedSitesRowIterator) Do(f func(row *SitesRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedSitesRowIterator) Stop() {}

type ShipmentsRowIterator interface {
	Next() (*ShipmentsRow, error)
	Do(f func(row *ShipmentsRow) error) error
	Stop()
}

type streamingShipmentsRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingShipmentsRowIterator) Next() (*ShipmentsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row ShipmentsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingShipmentsRowIterator) Do(f func(row *ShipmentsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row ShipmentsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedShipmentsRowIterator struct {
	rows []*ShipmentsRow
	err  error
}

func (i *bufferedShipmentsRowIterator) Next() (*ShipmentsRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedShipmentsRowIterator) Do(f func(row *ShipmentsRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedShipmentsRowIterator) Stop() {}

type LineItemsRowIterator interface {
	Next() (*LineItemsRow, error)
	Do(f func(row *LineItemsRow) error) error
	Stop()
}

type streamingLineItemsRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingLineItemsRowIterator) Next() (*LineItemsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row LineItemsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingLineItemsRowIterator) Do(f func(row *LineItemsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row LineItemsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedLineItemsRowIterator struct {
	rows []*LineItemsRow
	err  error
}

func (i *bufferedLineItemsRowIterator) Next() (*LineItemsRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedLineItemsRowIterator) Do(f func(row *LineItemsRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedLineItemsRowIterator) Stop() {}

type ReadTransaction struct {
	Tx SpannerReadTransaction
}

func Query(tx SpannerReadTransaction) ReadTransaction {
	return ReadTransaction{Tx: tx}
}

func (t ReadTransaction) ReadIamPolicyBindingsRows(
	ctx context.Context,
	keySet spanner.KeySet,
) IamPolicyBindingsRowIterator {
	return &streamingIamPolicyBindingsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"iam_policy_bindings",
			keySet,
			((*IamPolicyBindingsRow)(nil)).ColumnNames(),
		),
	}
}

type GetIamPolicyBindingsRowQuery struct {
	Key IamPolicyBindingsKey
}

func (t ReadTransaction) GetIamPolicyBindingsRow(
	ctx context.Context,
	query GetIamPolicyBindingsRowQuery,
) (*IamPolicyBindingsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"iam_policy_bindings",
		query.Key.SpannerKey(),
		((*IamPolicyBindingsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row IamPolicyBindingsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

type BatchGetIamPolicyBindingsRowsQuery struct {
	Keys []IamPolicyBindingsKey
}

func (t ReadTransaction) BatchGetIamPolicyBindingsRows(
	ctx context.Context,
	query BatchGetIamPolicyBindingsRowsQuery,
) (map[IamPolicyBindingsKey]*IamPolicyBindingsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[IamPolicyBindingsKey]*IamPolicyBindingsRow, len(query.Keys))
	if err := t.ReadIamPolicyBindingsRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *IamPolicyBindingsRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ListIamPolicyBindingsRowsQuery struct {
	Where  spansql.BoolExpr
	Order  []spansql.Order
	Limit  int32
	Offset int64
	Params map[string]interface{}
}

func (t ReadTransaction) ListIamPolicyBindingsRows(
	ctx context.Context,
	query ListIamPolicyBindingsRowsQuery,
) IamPolicyBindingsRowIterator {
	if len(query.Order) == 0 {
		query.Order = IamPolicyBindingsKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*IamPolicyBindingsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "iam_policy_bindings"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingIamPolicyBindingsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	return iter
}

func (t ReadTransaction) ReadShippersRows(
	ctx context.Context,
	keySet spanner.KeySet,
) ShippersRowIterator {
	return &streamingShippersRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"shippers",
			keySet,
			((*ShippersRow)(nil)).ColumnNames(),
		),
	}
}

type GetShippersRowQuery struct {
	Key ShippersKey
}

func (t ReadTransaction) GetShippersRow(
	ctx context.Context,
	query GetShippersRowQuery,
) (*ShippersRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"shippers",
		query.Key.SpannerKey(),
		((*ShippersRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row ShippersRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

type BatchGetShippersRowsQuery struct {
	Keys []ShippersKey
}

func (t ReadTransaction) BatchGetShippersRows(
	ctx context.Context,
	query BatchGetShippersRowsQuery,
) (map[ShippersKey]*ShippersRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[ShippersKey]*ShippersRow, len(query.Keys))
	if err := t.ReadShippersRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *ShippersRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ListShippersRowsQuery struct {
	Where       spansql.BoolExpr
	Order       []spansql.Order
	Limit       int32
	Offset      int64
	Params      map[string]interface{}
	ShowDeleted bool
}

func (t ReadTransaction) ListShippersRows(
	ctx context.Context,
	query ListShippersRowsQuery,
) ShippersRowIterator {
	if len(query.Order) == 0 {
		query.Order = ShippersKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	if !query.ShowDeleted {
		query.Where = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: spansql.Paren{Expr: query.Where},
			RHS: spansql.IsOp{
				LHS: spansql.ID("delete_time"),
				RHS: spansql.Null,
			},
		}
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*ShippersRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "shippers"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingShippersRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	return iter
}

func (t ReadTransaction) ReadSitesRows(
	ctx context.Context,
	keySet spanner.KeySet,
) SitesRowIterator {
	return &streamingSitesRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"sites",
			keySet,
			((*SitesRow)(nil)).ColumnNames(),
		),
	}
}

type GetSitesRowQuery struct {
	Key SitesKey
}

func (t ReadTransaction) GetSitesRow(
	ctx context.Context,
	query GetSitesRowQuery,
) (*SitesRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"sites",
		query.Key.SpannerKey(),
		((*SitesRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row SitesRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

type BatchGetSitesRowsQuery struct {
	Keys []SitesKey
}

func (t ReadTransaction) BatchGetSitesRows(
	ctx context.Context,
	query BatchGetSitesRowsQuery,
) (map[SitesKey]*SitesRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[SitesKey]*SitesRow, len(query.Keys))
	if err := t.ReadSitesRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *SitesRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ListSitesRowsQuery struct {
	Where       spansql.BoolExpr
	Order       []spansql.Order
	Limit       int32
	Offset      int64
	Params      map[string]interface{}
	ShowDeleted bool
}

func (t ReadTransaction) ListSitesRows(
	ctx context.Context,
	query ListSitesRowsQuery,
) SitesRowIterator {
	if len(query.Order) == 0 {
		query.Order = SitesKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	if !query.ShowDeleted {
		query.Where = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: spansql.Paren{Expr: query.Where},
			RHS: spansql.IsOp{
				LHS: spansql.ID("delete_time"),
				RHS: spansql.Null,
			},
		}
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*SitesRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "sites"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingSitesRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	return iter
}

func (t ReadTransaction) ReadShipmentsRows(
	ctx context.Context,
	keySet spanner.KeySet,
) ShipmentsRowIterator {
	return &streamingShipmentsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"shipments",
			keySet,
			((*ShipmentsRow)(nil)).ColumnNames(),
		),
	}
}

type GetShipmentsRowQuery struct {
	Key       ShipmentsKey
	LineItems bool
}

func (q *GetShipmentsRowQuery) hasInterleavedTables() bool {
	return q.LineItems
}

func (t ReadTransaction) GetShipmentsRow(
	ctx context.Context,
	query GetShipmentsRowQuery,
) (*ShipmentsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"shipments",
		query.Key.SpannerKey(),
		((*ShipmentsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row ShipmentsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	if !query.hasInterleavedTables() {
		return &row, nil
	}
	interleaved, err := t.readInterleavedShipmentsRows(ctx, readInterleavedShipmentsRowsQuery{
		KeySet:    row.Key().SpannerKey().AsPrefix(),
		LineItems: query.LineItems,
	})
	if err != nil {
		return nil, err
	}
	if rs, ok := interleaved.LineItems[row.Key()]; ok {
		row.LineItems = rs
	}
	return &row, nil
}

type BatchGetShipmentsRowsQuery struct {
	Keys      []ShipmentsKey
	LineItems bool
}

func (q *BatchGetShipmentsRowsQuery) hasInterleavedTables() bool {
	return q.LineItems
}

func (t ReadTransaction) BatchGetShipmentsRows(
	ctx context.Context,
	query BatchGetShipmentsRowsQuery,
) (map[ShipmentsKey]*ShipmentsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[ShipmentsKey]*ShipmentsRow, len(query.Keys))
	if err := t.ReadShipmentsRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *ShipmentsRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	if !query.hasInterleavedTables() {
		return foundRows, nil
	}
	interleaved, err := t.readInterleavedShipmentsRows(ctx, readInterleavedShipmentsRowsQuery{
		KeySet:    spanner.KeySets(spannerPrefixKeys...),
		LineItems: query.LineItems,
	})
	if err != nil {
		return nil, err
	}
	for _, row := range foundRows {
		if rs, ok := interleaved.LineItems[row.Key()]; ok {
			row.LineItems = rs
		}
	}
	return foundRows, nil
}

type ListShipmentsRowsQuery struct {
	Where       spansql.BoolExpr
	Order       []spansql.Order
	Limit       int32
	Offset      int64
	Params      map[string]interface{}
	ShowDeleted bool
	LineItems   bool
}

func (q *ListShipmentsRowsQuery) hasInterleavedTables() bool {
	return q.LineItems
}

func (t ReadTransaction) ListShipmentsRows(
	ctx context.Context,
	query ListShipmentsRowsQuery,
) ShipmentsRowIterator {
	if len(query.Order) == 0 {
		query.Order = ShipmentsKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	if !query.ShowDeleted {
		query.Where = spansql.LogicalOp{
			Op:  spansql.And,
			LHS: spansql.Paren{Expr: query.Where},
			RHS: spansql.IsOp{
				LHS: spansql.ID("delete_time"),
				RHS: spansql.Null,
			},
		}
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*ShipmentsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "shipments"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingShipmentsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	if !query.hasInterleavedTables() {
		return iter
	}
	rows := make([]*ShipmentsRow, 0, query.Limit)
	lookup := make(map[ShipmentsKey]*ShipmentsRow, query.Limit)
	prefixes := make([]spanner.KeySet, 0, query.Limit)
	if err := iter.Do(func(row *ShipmentsRow) error {
		k := row.Key()
		rows = append(rows, row)
		lookup[k] = row
		prefixes = append(prefixes, k.SpannerKey().AsPrefix())
		return nil
	}); err != nil {
		return &bufferedShipmentsRowIterator{err: err}
	}
	interleaved, err := t.readInterleavedShipmentsRows(ctx, readInterleavedShipmentsRowsQuery{
		KeySet:    spanner.KeySets(prefixes...),
		LineItems: query.LineItems,
	})
	if err != nil {
		return &bufferedShipmentsRowIterator{err: err}
	}
	for key, row := range lookup {
		if rs, ok := interleaved.LineItems[key]; ok {
			row.LineItems = rs
		}
	}
	return &bufferedShipmentsRowIterator{rows: rows}
}

type readInterleavedShipmentsRowsQuery struct {
	KeySet    spanner.KeySet
	LineItems bool
}

type readInterleavedShipmentsRowsResult struct {
	LineItems map[ShipmentsKey][]*LineItemsRow
}

func (t ReadTransaction) readInterleavedShipmentsRows(
	ctx context.Context,
	query readInterleavedShipmentsRowsQuery,
) (*readInterleavedShipmentsRowsResult, error) {
	var r readInterleavedShipmentsRowsResult
	if query.LineItems {
		r.LineItems = make(map[ShipmentsKey][]*LineItemsRow)
		if err := t.ReadLineItemsRows(ctx, query.KeySet).Do(func(row *LineItemsRow) error {
			k := ShipmentsKey{
				ShipperId:  row.ShipperId,
				ShipmentId: row.ShipmentId,
			}
			r.LineItems[k] = append(r.LineItems[k], row)
			return nil
		}); err != nil {
			return nil, err
		}
	}
	return &r, nil
}

func (t ReadTransaction) ReadLineItemsRows(
	ctx context.Context,
	keySet spanner.KeySet,
) LineItemsRowIterator {
	return &streamingLineItemsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"line_items",
			keySet,
			((*LineItemsRow)(nil)).ColumnNames(),
		),
	}
}

type GetLineItemsRowQuery struct {
	Key LineItemsKey
}

func (t ReadTransaction) GetLineItemsRow(
	ctx context.Context,
	query GetLineItemsRowQuery,
) (*LineItemsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"line_items",
		query.Key.SpannerKey(),
		((*LineItemsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row LineItemsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

type BatchGetLineItemsRowsQuery struct {
	Keys []LineItemsKey
}

func (t ReadTransaction) BatchGetLineItemsRows(
	ctx context.Context,
	query BatchGetLineItemsRowsQuery,
) (map[LineItemsKey]*LineItemsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[LineItemsKey]*LineItemsRow, len(query.Keys))
	if err := t.ReadLineItemsRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *LineItemsRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ListLineItemsRowsQuery struct {
	Where  spansql.BoolExpr
	Order  []spansql.Order
	Limit  int32
	Offset int64
	Params map[string]interface{}
}

func (t ReadTransaction) ListLineItemsRows(
	ctx context.Context,
	query ListLineItemsRowsQuery,
) LineItemsRowIterator {
	if len(query.Order) == 0 {
		query.Order = LineItemsKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*LineItemsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "line_items"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingLineItemsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	return iter
}

type SpannerReadTransaction interface {
	Read(ctx context.Context, table string, keys spanner.KeySet, columns []string) *spanner.RowIterator
	ReadRow(ctx context.Context, table string, key spanner.Key, columns []string) (*spanner.Row, error)
	Query(ctx context.Context, statement spanner.Statement) *spanner.RowIterator
}

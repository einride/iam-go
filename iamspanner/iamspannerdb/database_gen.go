package iamspannerdb

// Code generated by spanner-aip-go. DO NOT EDIT.

import (
	"context"
	"fmt"

	"cloud.google.com/go/spanner"
	"cloud.google.com/go/spanner/spansql"
	"google.golang.org/api/iterator"
)

type IamPolicyBindingsRow struct {
	Resource     string `spanner:"resource"`
	BindingIndex int64  `spanner:"binding_index"`
	Role         string `spanner:"role"`
	MemberIndex  int64  `spanner:"member_index"`
	Member       string `spanner:"member"`
}

func (*IamPolicyBindingsRow) ColumnNames() []string {
	return []string{
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	}
}

func (*IamPolicyBindingsRow) ColumnIDs() []spansql.ID {
	return []spansql.ID{
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	}
}

func (*IamPolicyBindingsRow) ColumnExprs() []spansql.Expr {
	return []spansql.Expr{
		spansql.ID("resource"),
		spansql.ID("binding_index"),
		spansql.ID("role"),
		spansql.ID("member_index"),
		spansql.ID("member"),
	}
}

func (r *IamPolicyBindingsRow) Validate() error {
	return nil
}

func (r *IamPolicyBindingsRow) UnmarshalSpannerRow(row *spanner.Row) error {
	for i := 0; i < row.Size(); i++ {
		switch row.ColumnName(i) {
		case "resource":
			if err := row.Column(i, &r.Resource); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: resource column: %w", err)
			}
		case "binding_index":
			if err := row.Column(i, &r.BindingIndex); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: binding_index column: %w", err)
			}
		case "role":
			if err := row.Column(i, &r.Role); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: role column: %w", err)
			}
		case "member_index":
			if err := row.Column(i, &r.MemberIndex); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: member_index column: %w", err)
			}
		case "member":
			if err := row.Column(i, &r.Member); err != nil {
				return fmt.Errorf("unmarshal iam_policy_bindings row: member column: %w", err)
			}
		default:
			return fmt.Errorf("unmarshal iam_policy_bindings row: unhandled column: %s", row.ColumnName(i))
		}
	}
	return nil
}

func (r *IamPolicyBindingsRow) Mutate() (string, []string, []interface{}) {
	return "iam_policy_bindings", r.ColumnNames(), []interface{}{
		r.Resource,
		r.BindingIndex,
		r.Role,
		r.MemberIndex,
		r.Member,
	}
}

func (r *IamPolicyBindingsRow) MutateColumns(columns []string) (string, []string, []interface{}) {
	if len(columns) == 0 {
		columns = r.ColumnNames()
	}
	values := make([]interface{}, 0, len(columns))
	for _, column := range columns {
		switch column {
		case "resource":
			values = append(values, r.Resource)
		case "binding_index":
			values = append(values, r.BindingIndex)
		case "role":
			values = append(values, r.Role)
		case "member_index":
			values = append(values, r.MemberIndex)
		case "member":
			values = append(values, r.Member)
		default:
			panic(fmt.Errorf("table iam_policy_bindings does not have column %s", column))
		}
	}
	return "iam_policy_bindings", columns, values
}

func (r *IamPolicyBindingsRow) MutatePresentColumns() (string, []string, []interface{}) {
	columns := make([]string, 0, len(r.ColumnNames()))
	columns = append(
		columns,
		"resource",
		"binding_index",
		"role",
		"member_index",
		"member",
	)
	return r.MutateColumns(columns)
}

func (r *IamPolicyBindingsRow) Key() IamPolicyBindingsKey {
	return IamPolicyBindingsKey{
		Resource:     r.Resource,
		BindingIndex: r.BindingIndex,
		Role:         r.Role,
		MemberIndex:  r.MemberIndex,
		Member:       r.Member,
	}
}

type IamPolicyBindingsKey struct {
	Resource     string
	BindingIndex int64
	Role         string
	MemberIndex  int64
	Member       string
}

func (k IamPolicyBindingsKey) SpannerKey() spanner.Key {
	return spanner.Key{
		k.Resource,
		k.BindingIndex,
		k.Role,
		k.MemberIndex,
		k.Member,
	}
}

func (k IamPolicyBindingsKey) SpannerKeySet() spanner.KeySet {
	return k.SpannerKey()
}

func (k IamPolicyBindingsKey) Delete() *spanner.Mutation {
	return spanner.Delete("iam_policy_bindings", k.SpannerKey())
}

func (IamPolicyBindingsKey) Order() []spansql.Order {
	return []spansql.Order{
		{Expr: spansql.ID("resource"), Desc: false},
		{Expr: spansql.ID("binding_index"), Desc: false},
		{Expr: spansql.ID("role"), Desc: false},
		{Expr: spansql.ID("member_index"), Desc: false},
		{Expr: spansql.ID("member"), Desc: false},
	}
}

func (k IamPolicyBindingsKey) BoolExpr() spansql.BoolExpr {
	cmp0 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("resource"),
		RHS: spansql.StringLiteral(k.Resource),
	})
	cmp1 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("binding_index"),
		RHS: spansql.IntegerLiteral(k.BindingIndex),
	})
	cmp2 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("role"),
		RHS: spansql.StringLiteral(k.Role),
	})
	cmp3 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("member_index"),
		RHS: spansql.IntegerLiteral(k.MemberIndex),
	})
	cmp4 := spansql.BoolExpr(spansql.ComparisonOp{
		Op:  spansql.Eq,
		LHS: spansql.ID("member"),
		RHS: spansql.StringLiteral(k.Member),
	})
	b := cmp0
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp1,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp2,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp3,
	}
	b = spansql.LogicalOp{
		Op:  spansql.And,
		LHS: b,
		RHS: cmp4,
	}
	return spansql.Paren{Expr: b}
}

type IamPolicyBindingsRowIterator interface {
	Next() (*IamPolicyBindingsRow, error)
	Do(f func(row *IamPolicyBindingsRow) error) error
	Stop()
}

type streamingIamPolicyBindingsRowIterator struct {
	*spanner.RowIterator
}

func (i *streamingIamPolicyBindingsRowIterator) Next() (*IamPolicyBindingsRow, error) {
	spannerRow, err := i.RowIterator.Next()
	if err != nil {
		return nil, err
	}
	var row IamPolicyBindingsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

func (i *streamingIamPolicyBindingsRowIterator) Do(f func(row *IamPolicyBindingsRow) error) error {
	return i.RowIterator.Do(func(spannerRow *spanner.Row) error {
		var row IamPolicyBindingsRow
		if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
			return err
		}
		return f(&row)
	})
}

type bufferedIamPolicyBindingsRowIterator struct {
	rows []*IamPolicyBindingsRow
	err  error
}

func (i *bufferedIamPolicyBindingsRowIterator) Next() (*IamPolicyBindingsRow, error) {
	if i.err != nil {
		return nil, i.err
	}
	if len(i.rows) == 0 {
		return nil, iterator.Done
	}
	next := i.rows[0]
	i.rows = i.rows[1:]
	return next, nil
}

func (i *bufferedIamPolicyBindingsRowIterator) Do(f func(row *IamPolicyBindingsRow) error) error {
	for {
		row, err := i.Next()
		switch err {
		case iterator.Done:
			return nil
		case nil:
			if err = f(row); err != nil {
				return err
			}
		default:
			return err
		}
	}
}

func (i *bufferedIamPolicyBindingsRowIterator) Stop() {}

type ReadTransaction struct {
	Tx SpannerReadTransaction
}

func Query(tx SpannerReadTransaction) ReadTransaction {
	return ReadTransaction{Tx: tx}
}

func (t ReadTransaction) ReadIamPolicyBindingsRows(
	ctx context.Context,
	keySet spanner.KeySet,
) IamPolicyBindingsRowIterator {
	return &streamingIamPolicyBindingsRowIterator{
		RowIterator: t.Tx.Read(
			ctx,
			"iam_policy_bindings",
			keySet,
			((*IamPolicyBindingsRow)(nil)).ColumnNames(),
		),
	}
}

type GetIamPolicyBindingsRowQuery struct {
	Key IamPolicyBindingsKey
}

func (t ReadTransaction) GetIamPolicyBindingsRow(
	ctx context.Context,
	query GetIamPolicyBindingsRowQuery,
) (*IamPolicyBindingsRow, error) {
	spannerRow, err := t.Tx.ReadRow(
		ctx,
		"iam_policy_bindings",
		query.Key.SpannerKey(),
		((*IamPolicyBindingsRow)(nil)).ColumnNames(),
	)
	if err != nil {
		return nil, err
	}
	var row IamPolicyBindingsRow
	if err := row.UnmarshalSpannerRow(spannerRow); err != nil {
		return nil, err
	}
	return &row, nil
}

type BatchGetIamPolicyBindingsRowsQuery struct {
	Keys []IamPolicyBindingsKey
}

func (t ReadTransaction) BatchGetIamPolicyBindingsRows(
	ctx context.Context,
	query BatchGetIamPolicyBindingsRowsQuery,
) (map[IamPolicyBindingsKey]*IamPolicyBindingsRow, error) {
	spannerKeys := make([]spanner.KeySet, 0, len(query.Keys))
	spannerPrefixKeys := make([]spanner.KeySet, 0, len(query.Keys))
	for _, key := range query.Keys {
		spannerKeys = append(spannerKeys, key.SpannerKey())
		spannerPrefixKeys = append(spannerPrefixKeys, key.SpannerKey().AsPrefix())
	}
	foundRows := make(map[IamPolicyBindingsKey]*IamPolicyBindingsRow, len(query.Keys))
	if err := t.ReadIamPolicyBindingsRows(ctx, spanner.KeySets(spannerKeys...)).Do(func(row *IamPolicyBindingsRow) error {
		foundRows[row.Key()] = row
		return nil
	}); err != nil {
		return nil, err
	}
	return foundRows, nil
}

type ListIamPolicyBindingsRowsQuery struct {
	Where  spansql.BoolExpr
	Order  []spansql.Order
	Limit  int32
	Offset int64
	Params map[string]interface{}
}

func (t ReadTransaction) ListIamPolicyBindingsRows(
	ctx context.Context,
	query ListIamPolicyBindingsRowsQuery,
) IamPolicyBindingsRowIterator {
	if len(query.Order) == 0 {
		query.Order = IamPolicyBindingsKey{}.Order()
	}
	params := make(map[string]interface{}, len(query.Params)+2)
	params["__limit"] = int64(query.Limit)
	params["__offset"] = int64(query.Offset)
	for param, value := range query.Params {
		if _, ok := params[param]; ok {
			panic(fmt.Errorf("invalid param: %s", param))
		}
		params[param] = value
	}
	if query.Where == nil {
		query.Where = spansql.True
	}
	stmt := spanner.Statement{
		SQL: spansql.Query{
			Select: spansql.Select{
				List: ((*IamPolicyBindingsRow)(nil)).ColumnExprs(),
				From: []spansql.SelectFrom{
					spansql.SelectFromTable{Table: "iam_policy_bindings"},
				},
				Where: query.Where,
			},
			Order:  query.Order,
			Limit:  spansql.Param("__limit"),
			Offset: spansql.Param("__offset"),
		}.SQL(),
		Params: params,
	}
	iter := &streamingIamPolicyBindingsRowIterator{
		RowIterator: t.Tx.Query(ctx, stmt),
	}
	return iter
}

type SpannerReadTransaction interface {
	Read(ctx context.Context, table string, keys spanner.KeySet, columns []string) *spanner.RowIterator
	ReadRow(ctx context.Context, table string, key spanner.Key, columns []string) (*spanner.Row, error)
	Query(ctx context.Context, statement spanner.Statement) *spanner.RowIterator
}
